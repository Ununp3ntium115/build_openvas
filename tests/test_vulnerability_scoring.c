/**
 * SPDX-FileCopyrightText: 2025 AI-Enhanced OpenVAS Project
 * SPDX-License-Identifier: GPL-2.0-or-later
 * 
 * Vulnerability Scoring System Test Suite
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <json-glib/json-glib.h>
#include "../ai-engine/scoring/vulnerability_scoring.h"

/* Test counters */
static int tests_run = 0;
static int tests_passed = 0;
static int tests_failed = 0;

/* Test macros */
#define TEST_START(name) \
    do { \
        tests_run++; \
        g_print("🧪 Testing %s... ", name); \
    } while(0)

#define TEST_PASS() \
    do { \
        tests_passed++; \
        g_print("✅ PASS\n"); \
    } while(0)

#define TEST_FAIL(reason) \
    do { \
        tests_failed++; \
        g_print("❌ FAIL: %s\n", reason); \
    } while(0)

#define ASSERT_TRUE(condition, message) \
    do { \
        if (!(condition)) { \
            TEST_FAIL(message); \
            return FALSE; \
        } \
    } while(0)

#define ASSERT_NOT_NULL(ptr, message) \
    do { \
        if ((ptr) == NULL) { \
            TEST_FAIL(message); \
            return FALSE; \
        } \
    } while(0)

#define ASSERT_DOUBLE_EQUAL(expected, actual, tolerance, message) \
    do { \
        if (fabs((expected) - (actual)) > (tolerance)) { \
            TEST_FAIL(g_strdup_printf("%s (expected: %.2f, got: %.2f)", message, expected, actual)); \
            return FALSE; \
        } \
    } while(0)

/**
 * @brief Test vulnerability score creation and cleanup
 */
static gboolean
test_vulnerability_score_lifecycle(void)
{
    TEST_START("vulnerability score lifecycle");
    
    const gchar *test_cve = "CVE-2023-12345";
    vulnerability_score_t *score = vulnerability_score_new(test_cve);
    
    ASSERT_NOT_NULL(score, "Failed to create vulnerability score");
    ASSERT_TRUE(g_strcmp0(score->cve_id, test_cve) == 0, "CVE ID not set correctly");
    ASSERT_TRUE(score->last_updated > 0, "Last updated timestamp not set");
    
    vulnerability_score_free(score);
    
    TEST_PASS();
    return TRUE;
}

/**
 * @brief Test CVSS v3.1 score calculation
 */
static gboolean
test_cvss_v31_calculation(void)
{
    TEST_START("CVSS v3.1 score calculation");
    
    // Create a CVSS v3.1 score for a critical vulnerability
    cvss_v3_t *cvss = g_malloc0(sizeof(cvss_v3_t));
    cvss->attack_vector = g_strdup("N");        // Network
    cvss->attack_complexity = g_strdup("L");    // Low
    cvss->privileges_required = g_strdup("N");  // None
    cvss->user_interaction = g_strdup("N");     // None
    cvss->scope = g_strdup("U");               // Unchanged
    cvss->confidentiality = g_strdup("H");     // High
    cvss->integrity = g_strdup("H");           // High
    cvss->availability = g_strdup("N");        // None
    
    gdouble calculated_score = cvss_v3_calculate_base_score(cvss);
    
    // This should result in a score around 9.1 (Critical)
    ASSERT_DOUBLE_EQUAL(9.1, calculated_score, 0.1, "CVSS v3.1 calculation incorrect");
    ASSERT_TRUE(cvss->severity == CVSS_SEVERITY_CRITICAL, "CVSS severity not set correctly");
    
    g_free(cvss->attack_vector);
    g_free(cvss->attack_complexity);
    g_free(cvss->privileges_required);
    g_free(cvss->user_interaction);
    g_free(cvss->scope);
    g_free(cvss->confidentiality);
    g_free(cvss->integrity);
    g_free(cvss->availability);
    g_free(cvss);
    
    TEST_PASS();
    return TRUE;
}

/**
 * @brief Test CVSS severity classification
 */
static gboolean
test_cvss_severity_classification(void)
{
    TEST_START("CVSS severity classification");
    
    ASSERT_TRUE(cvss_v3_get_severity(0.0) == CVSS_SEVERITY_NONE, "Score 0.0 should be None");
    ASSERT_TRUE(cvss_v3_get_severity(2.5) == CVSS_SEVERITY_LOW, "Score 2.5 should be Low");
    ASSERT_TRUE(cvss_v3_get_severity(5.0) == CVSS_SEVERITY_MEDIUM, "Score 5.0 should be Medium");
    ASSERT_TRUE(cvss_v3_get_severity(7.5) == CVSS_SEVERITY_HIGH, "Score 7.5 should be High");
    ASSERT_TRUE(cvss_v3_get_severity(9.5) == CVSS_SEVERITY_CRITICAL, "Score 9.5 should be Critical");
    
    TEST_PASS();
    return TRUE;
}

/**
 * @brief Test severity to string conversion
 */
static gboolean
test_severity_string_conversion(void)
{
    TEST_START("severity string conversion");
    
    ASSERT_TRUE(g_strcmp0(cvss_severity_to_string(CVSS_SEVERITY_NONE), "None") == 0, 
               "None severity string incorrect");
    ASSERT_TRUE(g_strcmp0(cvss_severity_to_string(CVSS_SEVERITY_LOW), "Low") == 0, 
               "Low severity string incorrect");
    ASSERT_TRUE(g_strcmp0(cvss_severity_to_string(CVSS_SEVERITY_MEDIUM), "Medium") == 0, 
               "Medium severity string incorrect");
    ASSERT_TRUE(g_strcmp0(cvss_severity_to_string(CVSS_SEVERITY_HIGH), "High") == 0, 
               "High severity string incorrect");
    ASSERT_TRUE(g_strcmp0(cvss_severity_to_string(CVSS_SEVERITY_CRITICAL), "Critical") == 0, 
               "Critical severity string incorrect");
    
    TEST_PASS();
    return TRUE;
}

/**
 * @brief Test SSVC decision string conversion
 */
static gboolean
test_ssvc_decision_conversion(void)
{
    TEST_START("SSVC decision string conversion");
    
    ASSERT_TRUE(g_strcmp0(ssvc_decision_to_string(SSVC_TRACK), "Track") == 0, 
               "Track decision string incorrect");
    ASSERT_TRUE(g_strcmp0(ssvc_decision_to_string(SSVC_TRACK_STAR), "Track*") == 0, 
               "Track* decision string incorrect");
    ASSERT_TRUE(g_strcmp0(ssvc_decision_to_string(SSVC_ATTEND), "Attend") == 0, 
               "Attend decision string incorrect");
    ASSERT_TRUE(g_strcmp0(ssvc_decision_to_string(SSVC_ACT), "Act") == 0, 
               "Act decision string incorrect");
    
    TEST_PASS();
    return TRUE;
}

/**
 * @brief Test AI composite risk score calculation
 */
static gboolean
test_ai_composite_risk_calculation(void)
{
    TEST_START("AI composite risk score calculation");
    
    vulnerability_score_t *score = vulnerability_score_new("CVE-2023-12345");
    
    // Set up CVSS v3.1 score
    score->cvss_v3_1 = g_malloc0(sizeof(cvss_v3_t));
    score->cvss_v3_1->base_score = 9.1;
    score->cvss_v3_1->severity = CVSS_SEVERITY_CRITICAL;
    
    // Set up KEV info (not in KEV)
    score->kev = g_malloc0(sizeof(kev_info_t));
    score->kev->is_kev = FALSE;
    
    // Set up EPSS info (low probability)
    score->epss = g_malloc0(sizeof(epss_info_t));
    score->epss->score = 0.00052;
    score->epss->percentile = 5.2;
    
    // Set up SSVC info
    score->ssvc = g_malloc0(sizeof(ssvc_info_t));
    score->ssvc->decision = SSVC_ATTEND;
    
    gdouble composite_score = ai_calculate_composite_risk_score(score);
    
    // Should be high due to CVSS score, despite low EPSS
    ASSERT_TRUE(composite_score > 7.0, "Composite score should be high for critical CVSS");
    ASSERT_TRUE(composite_score <= 10.0, "Composite score should not exceed 10.0");
    
    vulnerability_score_free(score);
    
    TEST_PASS();
    return TRUE;
}

/**
 * @brief Test AI priority determination
 */
static gboolean
test_ai_priority_determination(void)
{
    TEST_START("AI priority determination");
    
    vulnerability_score_t *score = vulnerability_score_new("CVE-2023-12345");
    
    // Test KEV vulnerability (should be CRITICAL)
    score->kev = g_malloc0(sizeof(kev_info_t));
    score->kev->is_kev = TRUE;
    
    gchar *priority = ai_determine_remediation_priority(score);
    ASSERT_TRUE(g_strcmp0(priority, "CRITICAL") == 0, "KEV vulnerability should be CRITICAL priority");
    g_free(priority);
    
    // Test high CVSS + high EPSS (should be CRITICAL)
    score->kev->is_kev = FALSE;
    score->cvss_v3_1 = g_malloc0(sizeof(cvss_v3_t));
    score->cvss_v3_1->severity = CVSS_SEVERITY_HIGH;
    score->epss = g_malloc0(sizeof(epss_info_t));
    score->epss->score = 0.15; // High EPSS
    
    priority = ai_determine_remediation_priority(score);
    ASSERT_TRUE(g_strcmp0(priority, "CRITICAL") == 0, "High CVSS + High EPSS should be CRITICAL");
    g_free(priority);
    
    // Test critical CVSS alone (should be HIGH)
    score->epss->score = 0.001; // Low EPSS
    score->cvss_v3_1->severity = CVSS_SEVERITY_CRITICAL;
    
    priority = ai_determine_remediation_priority(score);
    ASSERT_TRUE(g_strcmp0(priority, "HIGH") == 0, "Critical CVSS alone should be HIGH priority");
    g_free(priority);
    
    vulnerability_score_free(score);
    
    TEST_PASS();
    return TRUE;
}

/**
 * @brief Test vulnerability scoring system initialization
 */
static gboolean
test_scoring_system_initialization(void)
{
    TEST_START("scoring system initialization");
    
    ASSERT_TRUE(vulnerability_scoring_init(), "Failed to initialize vulnerability scoring system");
    
    // Test multiple initializations (should be safe)
    ASSERT_TRUE(vulnerability_scoring_init(), "Multiple initializations should be safe");
    
    vulnerability_scoring_cleanup();
    
    TEST_PASS();
    return TRUE;
}

/**
 * @brief Test comprehensive scoring workflow
 */
static gboolean
test_comprehensive_scoring_workflow(void)
{
    TEST_START("comprehensive scoring workflow");
    
    // Initialize scoring system
    ASSERT_TRUE(vulnerability_scoring_init(), "Failed to initialize scoring system");
    
    // Note: This test would normally fetch real data, but we'll test the structure
    const gchar *test_cve = "CVE-2023-12345";
    vulnerability_score_t *score = vulnerability_score_new(test_cve);
    
    // Simulate populated score data
    score->cvss_v3_1 = g_malloc0(sizeof(cvss_v3_t));
    score->cvss_v3_1->base_score = 9.1;
    score->cvss_v3_1->severity = CVSS_SEVERITY_CRITICAL;
    
    score->kev = g_malloc0(sizeof(kev_info_t));
    score->kev->is_kev = FALSE;
    
    score->epss = g_malloc0(sizeof(epss_info_t));
    score->epss->score = 0.00052;
    
    score->ssvc = g_malloc0(sizeof(ssvc_info_t));
    score->ssvc->decision = SSVC_ATTEND;
    
    // Test AI enhancement
    ASSERT_TRUE(ai_enhance_vulnerability_score(score), "AI enhancement failed");
    ASSERT_TRUE(score->ai_risk_score > 0.0, "AI risk score not calculated");
    ASSERT_NOT_NULL(score->ai_priority, "AI priority not set");
    ASSERT_NOT_NULL(score->ai_remediation_urgency, "Remediation urgency not set");
    
    vulnerability_score_free(score);
    vulnerability_scoring_cleanup();
    
    TEST_PASS();
    return TRUE;
}

/**
 * @brief Print test summary
 */
static void
print_test_summary(void)
{
    g_print("\n" "=" * 60 "\n");
    g_print("🧪 Vulnerability Scoring Test Summary\n");
    g_print("=" * 60 "\n");
    g_print("Total tests run: %d\n", tests_run);
    g_print("Tests passed: %d ✅\n", tests_passed);
    g_print("Tests failed: %d ❌\n", tests_failed);
    g_print("Success rate: %.1f%%\n", (float)tests_passed / tests_run * 100);
    g_print("=" * 60 "\n");
    
    if (tests_failed == 0) {
        g_print("🎉 All vulnerability scoring tests passed!\n");
        g_print("✅ CVSS calculation working correctly\n");
        g_print("✅ Severity classification accurate\n");
        g_print("✅ AI composite scoring functional\n");
        g_print("✅ Priority determination logic sound\n");
        g_print("✅ System initialization robust\n");
    } else {
        g_print("⚠️  Some tests failed. Please review the output above.\n");
    }
}

/**
 * @brief Main test function
 */
int
main(int argc, char *argv[])
{
    g_print("🚀 AI-Enhanced OpenVAS Vulnerability Scoring Test Suite\n");
    g_print("=" * 60 "\n");
    g_print("Testing comprehensive vulnerability scoring with CVSS, KEV, EPSS, and SSVC\n\n");
    
    // Run all tests
    test_vulnerability_score_lifecycle();
    test_cvss_v31_calculation();
    test_cvss_severity_classification();
    test_severity_string_conversion();
    test_ssvc_decision_conversion();
    test_ai_composite_risk_calculation();
    test_ai_priority_determination();
    test_scoring_system_initialization();
    test_comprehensive_scoring_workflow();
    
    // Print summary
    print_test_summary();
    
    return (tests_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}