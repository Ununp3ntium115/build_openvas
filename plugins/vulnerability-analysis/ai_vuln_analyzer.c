/**
 * SPDX-FileCopyrightText: 2025 AI-Enhanced OpenVAS Project
 * SPDX-License-Identifier: GPL-2.0-or-later
 * 
 * AI-Powered Vulnerability Analysis Plugin
 */

#include "../../ai-engine/api/ai_service.h"
#include <gvm/base/prefs.h>
#include <gvm/util/kb.h>

/**
 * @brief Enhanced vulnerability analysis structure
 */
typedef struct {
    gchar *nvt_oid;
    gchar *vulnerability_name;
    gchar *description;
    gchar *severity;
    gchar *cvss_score;
    gchar *cve_ids;
    gchar *affected_software;
    gchar *host_info;
    JsonObject *scan_results;
} vuln_context_t;

/**
 * @brief AI analysis result structure
 */
typedef struct {
    gchar *risk_assessment;
    gchar *business_impact;
    gchar *remediation_priority;
    gchar *detailed_remediation;
    gchar *exploit_likelihood;
    JsonArray *related_threats;
    gdouble confidence_score;
} ai_analysis_result_t;

/**
 * @brief Create vulnerability context from scan results
 */
static vuln_context_t *
create_vuln_context(const gchar *nvt_oid, JsonObject *scan_data)
{
    vuln_context_t *context = g_malloc0(sizeof(vuln_context_t));
    
    context->nvt_oid = g_strdup(nvt_oid);
    context->scan_results = json_object_ref(scan_data);
    
    // Extract vulnerability information from scan data
    if (json_object_has_member(scan_data, "name")) {
        context->vulnerability_name = g_strdup(
            json_object_get_string_member(scan_data, "name"));
    }
    
    if (json_object_has_member(scan_data, "description")) {
        context->description = g_strdup(
            json_object_get_string_member(scan_data, "description"));
    }
    
    if (json_object_has_member(scan_data, "severity")) {
        context->severity = g_strdup(
            json_object_get_string_member(scan_data, "severity"));
    }
    
    if (json_object_has_member(scan_data, "cvss_score")) {
        context->cvss_score = g_strdup(
            json_object_get_string_member(scan_data, "cvss_score"));
    }
    
    return context;
}

/**
 * @brief Free vulnerability context
 */
static void
free_vuln_context(vuln_context_t *context)
{
    if (!context) return;
    
    g_free(context->nvt_oid);
    g_free(context->vulnerability_name);
    g_free(context->description);
    g_free(context->severity);
    g_free(context->cvss_score);
    g_free(context->cve_ids);
    g_free(context->affected_software);
    g_free(context->host_info);
    
    if (context->scan_results)
        json_object_unref(context->scan_results);
    
    g_free(context);
}

/**
 * @brief Build AI analysis request payload
 */
static JsonObject *
build_analysis_payload(vuln_context_t *context)
{
    JsonBuilder *builder = json_builder_new();
    
    json_builder_begin_object(builder);
    
    // Vulnerability details
    json_builder_set_member_name(builder, "vulnerability");
    json_builder_begin_object(builder);
    
    if (context->vulnerability_name) {
        json_builder_set_member_name(builder, "name");
        json_builder_add_string_value(builder, context->vulnerability_name);
    }
    
    if (context->description) {
        json_builder_set_member_name(builder, "description");
        json_builder_add_string_value(builder, context->description);
    }
    
    if (context->severity) {
        json_builder_set_member_name(builder, "severity");
        json_builder_add_string_value(builder, context->severity);
    }
    
    if (context->cvss_score) {
        json_builder_set_member_name(builder, "cvss_score");
        json_builder_add_string_value(builder, context->cvss_score);
    }
    
    json_builder_end_object(builder);
    
    // Analysis request
    json_builder_set_member_name(builder, "analysis_request");
    json_builder_begin_object(builder);
    
    json_builder_set_member_name(builder, "required_analysis");
    json_builder_begin_array(builder);
    json_builder_add_string_value(builder, "risk_assessment");
    json_builder_add_string_value(builder, "business_impact");
    json_builder_add_string_value(builder, "remediation_priority");
    json_builder_add_string_value(builder, "detailed_remediation");
    json_builder_add_string_value(builder, "exploit_likelihood");
    json_builder_add_string_value(builder, "related_threats");
    json_builder_end_array(builder);
    
    json_builder_set_member_name(builder, "context");
    json_builder_add_string_value(builder, 
        "Provide a comprehensive security analysis focusing on practical "
        "remediation steps and business risk assessment. Include specific "
        "technical recommendations and prioritization guidance.");
    
    json_builder_end_object(builder);
    
    json_builder_end_object(builder);
    
    JsonNode *root = json_builder_get_root(builder);
    JsonObject *payload = json_object_ref(json_node_get_object(root));
    
    g_object_unref(builder);
    
    return payload;
}

/**
 * @brief Parse AI analysis response
 */
static ai_analysis_result_t *
parse_analysis_response(ai_response_t *response)
{
    if (!response || !response->success || !response->result) {
        return NULL;
    }
    
    ai_analysis_result_t *result = g_malloc0(sizeof(ai_analysis_result_t));
    result->confidence_score = response->confidence_score;
    
    // Parse the AI response content
    if (json_object_has_member(response->result, "content")) {
        const gchar *content = json_object_get_string_member(response->result, "content");
        
        // For now, store the full content - in production, you'd parse structured response
        result->risk_assessment = g_strdup(content);
        result->business_impact = g_strdup("AI analysis completed");
        result->remediation_priority = g_strdup("High");
        result->detailed_remediation = g_strdup(content);
        result->exploit_likelihood = g_strdup("Medium");
    }
    
    return result;
}

/**
 * @brief Free AI analysis result
 */
static void
free_analysis_result(ai_analysis_result_t *result)
{
    if (!result) return;
    
    g_free(result->risk_assessment);
    g_free(result->business_impact);
    g_free(result->remediation_priority);
    g_free(result->detailed_remediation);
    g_free(result->exploit_likelihood);
    
    if (result->related_threats)
        json_array_unref(result->related_threats);
    
    g_free(result);
}

/**
 * @brief Main AI vulnerability analysis function
 */
ai_analysis_result_t *
ai_analyze_vulnerability(const gchar *nvt_oid, JsonObject *scan_data)
{
    // Check if AI service is available
    if (!ai_service_is_available(AI_PROVIDER_OPENAI)) {
        g_warning("AI service not available for vulnerability analysis");
        return NULL;
    }
    
    // Create vulnerability context
    vuln_context_t *context = create_vuln_context(nvt_oid, scan_data);
    if (!context) {
        g_warning("Failed to create vulnerability context");
        return NULL;
    }
    
    // Build AI request
    JsonObject *payload = build_analysis_payload(context);
    ai_request_t *request = ai_request_new(AI_TASK_VULNERABILITY_ANALYSIS, payload);
    
    // Get AI configuration (this would typically come from preferences)
    ai_config_t *config = ai_config_new(AI_PROVIDER_OPENAI, 
                                       prefs_get("ai_openai_api_key"));
    request->config = config;
    
    // Process AI request
    ai_response_t *ai_response = ai_service_process_sync(request);
    
    // Parse results
    ai_analysis_result_t *analysis_result = parse_analysis_response(ai_response);
    
    // Cleanup
    free_vuln_context(context);
    json_object_unref(payload);
    ai_request_free(request);
    ai_config_free(config);
    ai_response_free(ai_response);
    
    return analysis_result;
}

/**
 * @brief Enhanced vulnerability reporting with AI insights
 */
gchar *
ai_generate_vulnerability_report(ai_analysis_result_t *analysis, 
                                vuln_context_t *context)
{
    if (!analysis || !context) {
        return NULL;
    }
    
    GString *report = g_string_new("");
    
    g_string_append_printf(report, "=== AI-Enhanced Vulnerability Analysis ===\n\n");
    
    if (context->vulnerability_name) {
        g_string_append_printf(report, "Vulnerability: %s\n", context->vulnerability_name);
    }
    
    if (context->severity) {
        g_string_append_printf(report, "Severity: %s\n", context->severity);
    }
    
    if (analysis->risk_assessment) {
        g_string_append_printf(report, "\nRisk Assessment:\n%s\n", 
                              analysis->risk_assessment);
    }
    
    if (analysis->business_impact) {
        g_string_append_printf(report, "\nBusiness Impact:\n%s\n", 
                              analysis->business_impact);
    }
    
    if (analysis->detailed_remediation) {
        g_string_append_printf(report, "\nRemediation Recommendations:\n%s\n", 
                              analysis->detailed_remediation);
    }
    
    g_string_append_printf(report, "\nAI Confidence Score: %.2f\n", 
                          analysis->confidence_score);
    
    return g_string_free(report, FALSE);
}

/**
 * @brief Plugin initialization
 */
gboolean
ai_vuln_analyzer_init(void)
{
    if (!ai_service_init()) {
        g_warning("Failed to initialize AI service for vulnerability analysis");
        return FALSE;
    }
    
    g_message("AI Vulnerability Analyzer plugin initialized");
    return TRUE;
}

/**
 * @brief Plugin cleanup
 */
void
ai_vuln_analyzer_cleanup(void)
{
    ai_service_cleanup();
    g_message("AI Vulnerability Analyzer plugin cleaned up");
}