/**
 * SPDX-FileCopyrightText: 2025 AI-Enhanced OpenVAS Project
 * SPDX-License-Identifier: GPL-2.0-or-later
 * 
 * Comprehensive Vulnerability Scoring System Implementation
 */

#include "vulnerability_scoring.h"
#include <math.h>
#include <string.h>
#include <curl/curl.h>

/* Global state */
static gboolean scoring_initialized = FALSE;
static GMutex scoring_mutex;

/* HTTP response structure for external API calls */
typedef struct {
    gchar *data;
    gsize size;
} http_response_t;

/**
 * @brief CURL write callback
 */
static size_t
curl_write_callback(void *contents, size_t size, size_t nmemb, http_response_t *response)
{
    size_t realsize = size * nmemb;
    response->data = g_realloc(response->data, response->size + realsize + 1);
    
    if (response->data) {
        memcpy(&(response->data[response->size]), contents, realsize);
        response->size += realsize;
        response->data[response->size] = 0;
    }
    
    return realsize;
}

/**
 * @brief Initialize vulnerability scoring system
 */
gboolean
vulnerability_scoring_init(void)
{
    if (scoring_initialized) {
        return TRUE;
    }
    
    g_mutex_init(&scoring_mutex);
    
    // Initialize CURL
    if (curl_global_init(CURL_GLOBAL_DEFAULT) != CURLE_OK) {
        g_warning("Failed to initialize CURL for vulnerability scoring");
        return FALSE;
    }
    
    scoring_initialized = TRUE;
    g_message("Vulnerability scoring system initialized");
    return TRUE;
}

/**
 * @brief Cleanup vulnerability scoring system
 */
void
vulnerability_scoring_cleanup(void)
{
    if (!scoring_initialized) {
        return;
    }
    
    curl_global_cleanup();
    g_mutex_clear(&scoring_mutex);
    scoring_initialized = FALSE;
    g_message("Vulnerability scoring system cleaned up");
}/**
 *
 @brief Create new vulnerability score
 */
vulnerability_score_t *
vulnerability_score_new(const gchar *cve_id)
{
    vulnerability_score_t *score = g_malloc0(sizeof(vulnerability_score_t));
    score->cve_id = g_strdup(cve_id);
    score->last_updated = g_get_real_time();
    return score;
}

/**
 * @brief Free vulnerability score
 */
void
vulnerability_score_free(vulnerability_score_t *score)
{
    if (!score) return;
    
    g_free(score->cve_id);
    g_free(score->vulnerability_name);
    g_free(score->description);
    g_free(score->published_date);
    g_free(score->last_modified);
    g_free(score->ai_priority);
    g_free(score->ai_remediation_urgency);
    
    if (score->cvss_v2) g_free(score->cvss_v2);
    if (score->cvss_v3_0) g_free(score->cvss_v3_0);
    if (score->cvss_v3_1) g_free(score->cvss_v3_1);
    if (score->cvss_v4_0) g_free(score->cvss_v4_0);
    if (score->kev) g_free(score->kev);
    if (score->epss) g_free(score->epss);
    if (score->ssvc) g_free(score->ssvc);
    if (score->ai_context) json_object_unref(score->ai_context);
    
    if (score->cwe_ids) g_strfreev(score->cwe_ids);
    if (score->references) g_strfreev(score->references);
    
    g_free(score);
}

/**
 * @brief Calculate CVSS v3.x base score
 */
gdouble
cvss_v3_calculate_base_score(cvss_v3_t *cvss)
{
    if (!cvss) return 0.0;
    
    // Impact Sub Score (ISS)
    gdouble conf_impact = 0.0, integ_impact = 0.0, avail_impact = 0.0;
    
    if (g_strcmp0(cvss->confidentiality, "N") == 0) conf_impact = 0.0;
    else if (g_strcmp0(cvss->confidentiality, "L") == 0) conf_impact = 0.22;
    else if (g_strcmp0(cvss->confidentiality, "H") == 0) conf_impact = 0.56;
    
    if (g_strcmp0(cvss->integrity, "N") == 0) integ_impact = 0.0;
    else if (g_strcmp0(cvss->integrity, "L") == 0) integ_impact = 0.22;
    else if (g_strcmp0(cvss->integrity, "H") == 0) integ_impact = 0.56;
    
    if (g_strcmp0(cvss->availability, "N") == 0) avail_impact = 0.0;
    else if (g_strcmp0(cvss->availability, "L") == 0) avail_impact = 0.22;
    else if (g_strcmp0(cvss->availability, "H") == 0) avail_impact = 0.56;
    
    gdouble iss = 1 - ((1 - conf_impact) * (1 - integ_impact) * (1 - avail_impact));
    
    // Impact calculation
    gdouble impact;
    if (g_strcmp0(cvss->scope, "U") == 0) {
        impact = 6.42 * iss;
    } else {
        impact = 7.52 * (iss - 0.029) - 3.25 * pow(iss - 0.02, 15);
    }
    
    // Exploitability calculation
    gdouble attack_vector_score = 0.0;
    if (g_strcmp0(cvss->attack_vector, "N") == 0) attack_vector_score = 0.85;
    else if (g_strcmp0(cvss->attack_vector, "A") == 0) attack_vector_score = 0.62;
    else if (g_strcmp0(cvss->attack_vector, "L") == 0) attack_vector_score = 0.55;
    else if (g_strcmp0(cvss->attack_vector, "P") == 0) attack_vector_score = 0.2;
    
    gdouble attack_complexity_score = 0.0;
    if (g_strcmp0(cvss->attack_complexity, "L") == 0) attack_complexity_score = 0.77;
    else if (g_strcmp0(cvss->attack_complexity, "H") == 0) attack_complexity_score = 0.44;
    
    gdouble privileges_required_score = 0.0;
    if (g_strcmp0(cvss->privileges_required, "N") == 0) {
        privileges_required_score = 0.85;
    } else if (g_strcmp0(cvss->privileges_required, "L") == 0) {
        privileges_required_score = (g_strcmp0(cvss->scope, "U") == 0) ? 0.62 : 0.68;
    } else if (g_strcmp0(cvss->privileges_required, "H") == 0) {
        privileges_required_score = (g_strcmp0(cvss->scope, "U") == 0) ? 0.27 : 0.50;
    }
    
    gdouble user_interaction_score = 0.0;
    if (g_strcmp0(cvss->user_interaction, "N") == 0) user_interaction_score = 0.85;
    else if (g_strcmp0(cvss->user_interaction, "R") == 0) user_interaction_score = 0.62;
    
    gdouble exploitability = 8.22 * attack_vector_score * attack_complexity_score * 
                            privileges_required_score * user_interaction_score;
    
    // Base Score calculation
    gdouble base_score;
    if (impact <= 0) {
        base_score = 0.0;
    } else {
        if (g_strcmp0(cvss->scope, "U") == 0) {
            base_score = fmin(impact + exploitability, 10.0);
        } else {
            base_score = fmin(1.08 * (impact + exploitability), 10.0);
        }
    }
    
    // Round up to one decimal place
    cvss->base_score = ceil(base_score * 10.0) / 10.0;
    cvss->severity = cvss_v3_get_severity(cvss->base_score);
    
    return cvss->base_score;
}

/**
 * @brief Get CVSS v3 severity from base score
 */
cvss_severity_t
cvss_v3_get_severity(gdouble base_score)
{
    if (base_score == 0.0) return CVSS_SEVERITY_NONE;
    else if (base_score >= 0.1 && base_score <= 3.9) return CVSS_SEVERITY_LOW;
    else if (base_score >= 4.0 && base_score <= 6.9) return CVSS_SEVERITY_MEDIUM;
    else if (base_score >= 7.0 && base_score <= 8.9) return CVSS_SEVERITY_HIGH;
    else if (base_score >= 9.0 && base_score <= 10.0) return CVSS_SEVERITY_CRITICAL;
    else return CVSS_SEVERITY_NONE;
}

/**
 * @brief Convert CVSS severity to string
 */
const gchar *
cvss_severity_to_string(cvss_severity_t severity)
{
    switch (severity) {
        case CVSS_SEVERITY_NONE: return "None";
        case CVSS_SEVERITY_LOW: return "Low";
        case CVSS_SEVERITY_MEDIUM: return "Medium";
        case CVSS_SEVERITY_HIGH: return "High";
        case CVSS_SEVERITY_CRITICAL: return "Critical";
        default: return "Unknown";
    }
}

/**
 * @brief Convert SSVC decision to string
 */
const gchar *
ssvc_decision_to_string(ssvc_decision_t decision)
{
    switch (decision) {
        case SSVC_TRACK: return "Track";
        case SSVC_TRACK_STAR: return "Track*";
        case SSVC_ATTEND: return "Attend";
        case SSVC_ACT: return "Act";
        default: return "Unknown";
    }
}